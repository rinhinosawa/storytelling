<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <title>Mapbox Storytelling</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <link rel="icon" type="image/x-icon"
        href="https://raw.githubusercontent.com/mapbox/assembly/publisher-staging/src/svgs/mapbox.svg">
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://cdn.jsdelivr.net/npm/mapbox-gl-globe-minimap@1.2.0/dist/bundle.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Helvetica, sans-serif;
        }

        a,
        a:hover,
        a:visited {
            color: #0071bc;
        }

        #map {
            top: 0;
            height: 100vh;
            width: 100vw;
            position: fixed;
        }

        #header {
            margin: auto;
            width: 100%;
            position: relative;
            z-index: 5;
        }

        #header h1,
        #header h2,
        #header p {
            margin: 0;
            padding: 2vh 2vw;
            text-align: center;
        }

        #field-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(68, 68, 68, 0.95);
            padding: 12px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            font-family: Helvetica, sans-serif;
            font-size: 14px;
            z-index: 1000;
            min-width: 200px;
            max-width: 250px;
            transition: right 0.3s ease, left 0.3s ease;
        }
        
        #field-display.align-left {
            right: auto;
            left: 20px;
        }
        
        #field-display .field-label {
            font-weight: 600;
            color: #fafafa;
            margin-bottom: 4px;
        }
        
        #field-display .field-name {
            color: #fafafa;
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 12px;
        }
        
        #field-display .legend {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(250, 250, 250, 0.2);
        }
        
        #field-display .legend-label {
            font-size: 11px;
            color: #fafafa;
            opacity: 0.8;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        #field-display .legend-ranges {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        #field-display .legend-range-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #field-display .legend-swatch {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }
        
        #field-display .legend-range-text {
            font-size: 10px;
            color: #fafafa;
            opacity: 0.8;
        }

        #footer {
            width: 100%;
            min-height: 5vh;
            padding-top: 2vh;
            padding-bottom: 2vh;
            text-align: center;
            line-height: 25px;
            font-size: 13px;
            position: relative;
            z-index: 5;
        }

        #features {
            padding-top: 10vh;
            padding-bottom: 10vh;
        }

        .hidden {
            visibility: hidden;
        }

        .centered {
            width: 55vw;
            margin: 0 auto;
        }

        .lefty {
            width: 40vw;
            margin-left: 5vw;
        }

        .righty {
            width: 40vw;
            margin-left: 55vw;
        }

        .fully {
            width: 100%;
            margin: auto;
        }

        .light {
            color: #444;
            background-color: #fafafa;
        }

        .dark {
            color: #fafafa;
            background-color: #444;
        }

        .step {
            padding-bottom: 50vh;
            /* margin-bottom: 10vh; */
            opacity: 0.25;
        }

        .step.active {
            opacity: 0.9;
        }

        .step div {
            padding: 25px 50px;
            line-height: 25px;
            font-size: 13px;
        }

        .step img {
            width: 100%;
        }

        @media (max-width: 750px) {

            .centered,
            .lefty,
            .righty,
            .fully {
                width: 90vw;
                margin: 0 auto;
            }
        }

        /* Fix issue on mobile browser where scroll breaks  */
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas {
            touch-action: unset;
        }
    </style>
</head>

<body>

    <div id="map"></div>
    <div id="story"></div>
    <div id="field-display"></div>

    <script src="./config.js"></script>
    <script>
        var initLoad = true;
        var layerTypes = {
            'fill': ['fill-opacity'],
            'line': ['line-opacity'],
            'circle': ['circle-opacity', 'circle-stroke-opacity'],
            'symbol': ['icon-opacity', 'text-opacity'],
            'raster': ['raster-opacity'],
            'fill-extrusion': ['fill-extrusion-opacity'],
            'heatmap': ['heatmap-opacity']
        }

        var alignments = {
            'left': 'lefty',
            'center': 'centered',
            'right': 'righty',
            'full': 'fully'
        }

        function getLayerPaintType(layer) {
            var layerType = map.getLayer(layer).type;
            return layerTypes[layerType];
        }

        function setLayerOpacity(layer) {
            if (!map.getLayer(layer.layer)) {
                console.warn('Layer not found:', layer.layer);
                return;
            }
            
            const paintProps = getLayerPaintType(layer.layer);
            const options = layer.duration ? { duration: layer.duration } : {};
            
            paintProps.forEach(prop => {
                if (layer.duration) {
                    map.setPaintProperty(layer.layer, prop + '-transition', options);
                }
                
                if (layer.layer === 'census-choropleth' && prop === 'fill-opacity') {
                    if (layer.opacity === 0) {
                        map.setPaintProperty(layer.layer, prop, 0, options);
                    } else {
                        const colorData = calculateColorBreaks(currentField);
                        if (colorData) {
                            const validation = createFieldValidation(currentField, colorData.minValue, colorData.maxValue);
                            map.setPaintProperty(layer.layer, prop, ['case', validation, 0.7, 0], options);
                        }
                    }
                    
                    const fieldDisplay = document.getElementById('field-display');
                    if (fieldDisplay) {
                        fieldDisplay.style.display = layer.opacity > 0 ? 'block' : 'none';
                    }
                } else {
                    map.setPaintProperty(layer.layer, prop, layer.opacity, options);
                }
            });
        }

        var story = document.getElementById('story');
        var features = document.createElement('div');
        features.setAttribute('id', 'features');

        var header = document.createElement('div');

        if (config.title) {
            var titleText = document.createElement('h1');
            titleText.innerText = config.title;
            header.appendChild(titleText);
        }

        if (config.subtitle) {
            var subtitleText = document.createElement('h2');
            subtitleText.innerText = config.subtitle;
            header.appendChild(subtitleText);
        }

        if (config.byline) {
            var bylineText = document.createElement('p');
            bylineText.innerText = config.byline;
            header.appendChild(bylineText);
        }

        if (header.innerText.length > 0) {
            header.classList.add(config.theme);
            header.setAttribute('id', 'header');
            story.appendChild(header);
        }

        config.chapters.forEach((record, idx) => {
            var container = document.createElement('div');
            var chapter = document.createElement('div');

            if (record.title) {
                var title = document.createElement('h3');
                title.innerText = record.title;
                chapter.appendChild(title);
            }

            if (record.image) {
                var image = new Image();
                image.src = record.image;
                chapter.appendChild(image);
            }

            if (record.description) {
                var story = document.createElement('p');
                story.innerHTML = record.description;
                chapter.appendChild(story);
            }

            container.setAttribute('id', record.id);
            container.classList.add('step');
            if (idx === 0) {
                container.classList.add('active');
            }

            chapter.classList.add(config.theme);
            container.appendChild(chapter);
            container.classList.add(alignments[record.alignment] || 'centered');
            if (record.hidden) {
                container.classList.add('hidden');
            }
            features.appendChild(container);
        });

        story.appendChild(features);

        var footer = document.createElement('div');

        if (config.footer) {
            var footerText = document.createElement('p');
            footerText.innerHTML = config.footer;
            footer.appendChild(footerText);
        }

        if (footer.innerText.length > 0) {
            footer.classList.add(config.theme);
            footer.setAttribute('id', 'footer');
            story.appendChild(footer);
        }

        mapboxgl.accessToken = config.accessToken;

        var map = new mapboxgl.Map({
            container: 'map',
            style: config.style,
            center: config.chapters[0].location.center,
            zoom: config.chapters[0].location.zoom,
            bearing: config.chapters[0].location.bearing,
            pitch: config.chapters[0].location.pitch,
            interactive: false,
            projection: config.projection
        });

        // Create a inset map if enabled in config.js
        if (config.inset) {
            map.addControl(
                new GlobeMinimap({ ...config.insetOptions }),
                config.insetPosition
            );
        }

        if (config.showMarkers) {
            var marker = new mapboxgl.Marker({ color: config.markerColor });
            marker.setLngLat(config.chapters[0].location.center).addTo(map);
        }

        // instantiate the scrollama
        var scroller = scrollama();

        // Simple CSV parser - handles triple quotes
        function parseCSV(text) {
            const lines = text.split('\n').filter(l => l.trim());
            if (!lines.length) return [];
            const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let char of lines[i]) {
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.replace(/^"+|"+$/g, '').trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.replace(/^"+|"+$/g, '').trim());
                const row = {};
                headers.forEach((h, j) => {
                    let val = values[j] || '';
                    const num = parseFloat(val);
                    row[h] = isNaN(num) ? val : num;
                });
                data.push(row);
            }
            return data;
        }

        // Store the loaded GeoJSON data globally so we can update fields
        let censusGeoJSON = null;
        let currentField = config.data.defaultField;
        let currentBreaks = null;
        
        // Helper: Create field validation expression
        function createFieldValidation(fieldName, minVal, maxVal) {
            return [
                'all',
                ['has', fieldName],
                ['!=', ['get', fieldName], null],
                ['!=', ['get', fieldName], ''],
                ['>=', ['to-number', ['get', fieldName]], minVal],
                ['<=', ['to-number', ['get', fieldName]], maxVal]
            ];
        }
        
        // Helper: Normalize GEOID to consistent format
        function normalizeGeoid(id) {
            return String(id || '').trim().replace(/^"+|"+$/g, '').padStart(12, '0');
        }
        
        // Helper: Calculate color breaks and stops
        function calculateColorBreaks(fieldName) {
            if (!censusGeoJSON) return null;
            
            const values = censusGeoJSON.features
                .map(f => parseFloat(f.properties[fieldName]))
                .filter(v => !isNaN(v))
                .sort((a, b) => a - b);
            
            if (values.length === 0) return null;
            
            const quantiles = [0, 0.2, 0.4, 0.6, 0.8, 1];
            const breaks = quantiles.map(p => 
                Number(values[Math.min(Math.floor((values.length - 1) * p), values.length - 1)])
            );
            
            const colors = ['#ffffcc', '#c7e9b4', '#7fcdbb', '#41b6c4', '#2c7fb8', '#253494'];
            const stops = breaks.map((b, i) => [b, colors[i]]).flat();
            
            return { breaks, stops, minValue: breaks[0], maxValue: breaks[breaks.length - 1] };
        }
        
        // Data dictionary mapping field codes to full labels
        const fieldLabels = {
            'ht_ami': 'Housing + Transportation Costs as a Percent of Income for a Typical Household',
            'h_ami': 'Housing Costs as a Percent of Income for a Typical Household',
            't_ami': 'Transportation Costs as a Percent of Income for a Typical Household',
            'compact_ndx': 'Compact Neighborhood Score (0-10)',
            'emp_ovrll_ndx': 'Job Access Score (0-10)',
            'frac_sfd': 'Percent of Single Family Detached Households',
            'emp_gravity': 'Employment Access Index',
            'hh_gravity': 'Regional Household Intensity',
            'median_gross_rent': 'Median Gross Monthly Rent'
        };
        
        // Update the field display widget with legend
        function updateFieldDisplay(fieldName, breaks = null) {
            const displayEl = document.getElementById('field-display');
            if (!displayEl) return;
            
            currentField = fieldName;
            const label = fieldLabels[fieldName] || fieldName;
            
            // Store breaks if provided
            if (breaks) {
                currentBreaks = breaks;
            }
            
            // Format numbers for display (remove trailing .0 and add %)
            const formatValue = (val) => {
                let formatted;
                if (val >= 1000) {
                    formatted = val.toFixed(0);
                } else if (val >= 1) {
                    formatted = val.toFixed(1);
                } else {
                    formatted = val.toFixed(2);
                }
                // Remove trailing .0
                formatted = formatted.replace(/\.0+$/, '');
                // Add percentage sign
                return formatted + '%';
            };
            
            let legendHTML = '';
            if (currentBreaks && currentBreaks.length > 1) {
                const colors = ['#ffffcc', '#c7e9b4', '#7fcdbb', '#41b6c4', '#2c7fb8', '#253494'];
                
                // Create ranges between consecutive breaks
                const rangeItems = [];
                for (let i = 0; i < currentBreaks.length - 1; i++) {
                    const minVal = formatValue(currentBreaks[i]);
                    const maxVal = formatValue(currentBreaks[i + 1]);
                    const color = colors[i];
                    
                    rangeItems.push(`
                        <div class="legend-range-item">
                            <div class="legend-swatch" style="background-color: ${color};"></div>
                            <div class="legend-range-text">${minVal} - ${maxVal}</div>
                        </div>
                    `);
                }
                
                legendHTML = `
                    <div class="legend">
                        <div class="legend-label">Value Range</div>
                        <div class="legend-ranges">
                            ${rangeItems.join('')}
                        </div>
                    </div>
                `;
            }
            
            displayEl.innerHTML = `
                <div class="field-label">Legend</div>
                <div class="field-name">${label}</div>
                ${legendHTML}
            `;
        }
        
        // Update the visualized field dynamically with smooth transition
        function updateCensusField(fieldName) {
            if (!censusGeoJSON || !map.getLayer('census-choropleth')) return;
            
            const colorData = calculateColorBreaks(fieldName);
            if (!colorData) return;
            
            updateFieldDisplay(fieldName, colorData.breaks);
            
            const validation = createFieldValidation(fieldName, colorData.minValue, colorData.maxValue);
            const transition = { duration: 4800, delay: 0 };
            
            map.setPaintProperty('census-choropleth', 'fill-color-transition', transition);
            map.setPaintProperty('census-choropleth', 'fill-color', [
                'case',
                validation,
                ['interpolate', ['linear'], ['to-number', ['get', fieldName]], ...colorData.stops],
                'rgba(255, 255, 255, 0)'
            ]);
            map.setPaintProperty('census-choropleth', 'fill-opacity', ['case', validation, 0.7, 0]);
            
            if (map.getLayer('census-borders')) {
                map.setPaintProperty('census-borders', 'line-opacity', ['case', validation, 0.3, 0]);
            }
        }
        
        // Load and visualize census data (hidden initially)
        async function loadCensusData(beforeId = null) {
            if (map.getLayer('census-choropleth') && map.getSource('census-data')) return;
            
            try {
                const geojson = await fetch(config.data.geojson).then(r => r.json());
                censusGeoJSON = geojson;
                
                // Use currentField if set, otherwise fall back to defaultField
                const field = currentField || config.data.defaultField;
                const colorData = calculateColorBreaks(field);
                if (!colorData) return;
                
                const { breaks, stops, minValue, maxValue } = colorData;
                const validation = createFieldValidation(field, minValue, maxValue);
                
                if (!map.getSource('census-data')) {
                    map.addSource('census-data', { type: 'geojson', data: geojson });
                } else {
                    map.getSource('census-data').setData(geojson);
                }
                
                if (!map.getLayer('census-choropleth')) {
                    map.addLayer({
                        id: 'census-choropleth',
                        type: 'fill',
                        source: 'census-data',
                        paint: {
                            'fill-color': ['case', validation, ['interpolate', ['linear'], ['to-number', ['get', field]], ...stops], 'rgba(255, 255, 255, 0)'],
                            'fill-opacity': ['case', validation, 0, 0] // Start hidden
                        }
                    }, beforeId);
                    
                    map.addLayer({
                        id: 'census-borders',
                        type: 'line',
                        source: 'census-data',
                        paint: {
                            'line-color': '#ffffff',
                            'line-width': 0.5,
                            'line-opacity': ['case', validation, 0, 0] // Start hidden
                        }
                    }, beforeId);
                    
                    updateFieldDisplay(field, breaks);
                    document.getElementById('field-display').style.display = 'none'; // Hidden initially
                }
            } catch (e) {
                console.error('Error loading census data:', e);
            }
        }
        
        // Show census data once everything is ready
        function showCensusData() {
            if (!map.getLayer('census-choropleth')) return;
            
            const field = currentField || config.data.defaultField;
            const colorData = calculateColorBreaks(field);
            if (!colorData) return;
            
            const validation = createFieldValidation(field, colorData.minValue, colorData.maxValue);
            
            map.setPaintProperty('census-choropleth', 'fill-opacity', ['case', validation, 0.7, 0]);
            map.setPaintProperty('census-borders', 'line-opacity', ['case', validation, 0.3, 0]);
            
            const fieldDisplay = document.getElementById('field-display');
            if (fieldDisplay) {
                fieldDisplay.style.display = 'block';
            }
        }
        
        // Load overlay style and add its layers on top
        let overlayLoading = false;
        async function loadOverlayStyle() {
            if (overlayLoading) return;
            overlayLoading = true;
            
            try {
                const styleId = config.overlayStyle.replace('mapbox://styles/', '');
                const styleUrl = `https://api.mapbox.com/styles/v1/${styleId}?access_token=${config.accessToken}`;
                
                const response = await fetch(styleUrl);
                const overlayStyle = await response.json();
                
                if (!overlayStyle.sources || !overlayStyle.layers) {
                    overlayLoading = false;
                    return;
                }
                
                // Wait for census data to be fully loaded first
                if (config.data && config.data.geojson) {
                    let attempts = 0;
                    while (!map.getLayer('census-choropleth') && attempts < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }
                }
                
                // Add all sources from overlay style
                for (const [sourceId, source] of Object.entries(overlayStyle.sources)) {
                    const prefixedSourceId = `overlay-${sourceId}`;
                    if (!map.getSource(prefixedSourceId)) {
                        map.addSource(prefixedSourceId, source);
                    }
                }
                
                // Add all layers from overlay style
                for (const layer of overlayStyle.layers) {
                    const prefixedLayerId = `overlay-${layer.id}`;
                    if (map.getLayer(prefixedLayerId)) continue;
                    
                    const layerCopy = JSON.parse(JSON.stringify(layer));
                    layerCopy.id = prefixedLayerId;
                    if (layerCopy.source) {
                        layerCopy.source = `overlay-${layerCopy.source}`;
                    }
                    map.addLayer(layerCopy);
                }
            } catch (e) {
                console.error('Error loading overlay style:', e);
            } finally {
                overlayLoading = false;
            }
        }


        map.on("load", function () {
            if (config.use3dTerrain) {
                map.addSource('mapbox-dem', {
                    'type': 'raster-dem',
                    'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
                    'tileSize': 512,
                    'maxzoom': 14
                });
                // add the DEM source as a terrain layer with exaggerated height
                map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

                // add a sky layer that will show when the map is highly pitched
                map.addLayer({
                    'id': 'sky',
                    'type': 'sky',
                    'paint': {
                        'sky-type': 'atmosphere',
                        'sky-atmosphere-sun': [0.0, 0.0],
                        'sky-atmosphere-sun-intensity': 15
                    }
                });
            }

            // Load all data and layers first, then show everything together
            if (config.data && config.data.geojson) {
                const loadAllData = async () => {
                    // Wait for symbol layers to be available (retry up to 10 times)
                    let firstSymbol = null;
                    let attempts = 0;
                    while (!firstSymbol && attempts < 10) {
                        const layers = map.getStyle().layers;
                        firstSymbol = layers?.find(l => l.type === 'symbol');
                        if (!firstSymbol) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                            attempts++;
                        }
                    }
                    
                    // Load census data (hidden) - use beforeId if symbol found, otherwise null
                    await loadCensusData(firstSymbol?.id || null);
                    
                    // Load overlay style if needed
                    if (config.overlayStyle) {
                        await loadOverlayStyle();
                    }
                    
                    // Wait a moment for all layers to be fully ready
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Now show everything together
                    showCensusData();
                };
                
                loadAllData();
                map.once('styledata', loadAllData);
            } else if (config.overlayStyle) {
                loadOverlayStyle();
            }
            
            // Track current style state for bidirectional navigation
            let currentStyleState = 'default'; // 'default' or 'satellite'
            
            // Style toggle functions - accessible via chapter callbacks
            window.switchToSatellite = function(chapterConfig = null) {
                if (!config.satelliteStyle) return;
                
                // Check if chapter wants to hide data (opacity 0 in onChapterEnter)
                let shouldHideData = false;
                if (chapterConfig && chapterConfig.onChapterEnter) {
                    shouldHideData = chapterConfig.onChapterEnter.some(layerConfig => 
                        layerConfig.layer === 'census-choropleth' && layerConfig.opacity === 0
                    );
                }
                
                map.setStyle(config.satelliteStyle);
                currentStyleState = 'satellite';
                
                // After style loads, restore census layers on top
                map.once('styledata', () => {
                    // Wait a moment for style to fully load
                    setTimeout(() => {
                        if (!map.getLayer('census-choropleth')) {
                            // Re-add census layers
                            const layers = map.getStyle().layers;
                            const firstSymbol = layers.find(layer => layer.type === 'symbol');
                            if (firstSymbol) {
                                loadCensusData(firstSymbol.id).then(() => {
                                    // Only show data if chapter doesn't want it hidden
                                    if (!shouldHideData) {
                                        showCensusData();
                                    } else {
                                        // Explicitly hide data if chapter wants it hidden
                                        window.hideCensusData();
                                    }
                                });
                            } else {
                                loadCensusData(null).then(() => {
                                    // Only show data if chapter doesn't want it hidden
                                    if (!shouldHideData) {
                                        showCensusData();
                                    } else {
                                        // Explicitly hide data if chapter wants it hidden
                                        window.hideCensusData();
                                    }
                                });
                            }
                        } else {
                            // Layers already exist
                            if (!shouldHideData) {
                                showCensusData();
                            } else {
                                // Explicitly hide data if chapter wants it hidden
                                window.hideCensusData();
                            }
                        }
                    }, 500);
                });
            };
            
            window.switchToDefault = function() {
                if (currentStyleState === 'default') {
                    return Promise.resolve();
                }
                
                return new Promise((resolve) => {
                    map.setStyle(config.style);
                    currentStyleState = 'default';
                    
                    map.once('styledata', () => {
                        if (config.overlayStyle) {
                            loadOverlayStyle();
                        }
                        
                        setTimeout(async () => {
                            if (!map.getLayer('census-choropleth')) {
                                const layers = map.getStyle().layers;
                                const firstSymbol = layers.find(layer => layer.type === 'symbol');
                                if (firstSymbol) {
                                    await loadCensusData(firstSymbol.id);
                                } else {
                                    await loadCensusData(null);
                                }
                                resolve();
                            } else {
                                const colorData = calculateColorBreaks(currentField);
                                if (colorData) {
                                    const validation = createFieldValidation(currentField, colorData.minValue, colorData.maxValue);
                                    map.setPaintProperty('census-choropleth', 'fill-opacity', ['case', validation, 0.7, 0]);
                                    if (map.getLayer('census-borders')) {
                                        map.setPaintProperty('census-borders', 'line-opacity', ['case', validation, 0.3, 0]);
                                    }
                                }
                                document.getElementById('field-display')?.style.setProperty('display', 'block');
                                resolve();
                            }
                        }, 1500);
                    });
                });
            };
            
            window.hideCensusData = function() {
                if (map.getLayer('census-choropleth')) map.setPaintProperty('census-choropleth', 'fill-opacity', 0);
                if (map.getLayer('census-borders')) map.setPaintProperty('census-borders', 'line-opacity', 0);
                document.getElementById('field-display')?.style.setProperty('display', 'none');
            };
            
            window.showCensusData = function() {
                const colorData = calculateColorBreaks(currentField);
                if (colorData) {
                    const validation = createFieldValidation(currentField, colorData.minValue, colorData.maxValue);
                    if (map.getLayer('census-choropleth')) {
                        map.setPaintProperty('census-choropleth', 'fill-opacity', ['case', validation, 0.7, 0]);
                    }
                    if (map.getLayer('census-borders')) {
                        map.setPaintProperty('census-borders', 'line-opacity', ['case', validation, 0.3, 0]);
                    }
                }
                document.getElementById('field-display')?.style.setProperty('display', 'block');
            };

            // setup the instance, pass callback functions
            scroller
                .setup({
                    step: '.step',
                    offset: 0.5,
                    progress: true
                })
                .onStepEnter(async response => {
                    var current_chapter = config.chapters.findIndex(chap => chap.id === response.element.id);
                    var chapter = config.chapters[current_chapter];

                    response.element.classList.add('active');
                    map[chapter.mapAnimation || 'flyTo'](chapter.location);

                    if (config.showMarkers) {
                        marker.setLngLat(chapter.location.center);
                    }
                    
                    // Update legend position based on chapter alignment
                    const fieldDisplay = document.getElementById('field-display');
                    if (fieldDisplay) {
                        if (chapter.alignment === 'right') {
                            fieldDisplay.classList.add('align-left');
                        } else {
                            fieldDisplay.classList.remove('align-left');
                        }
                    }
                    
                    // Execute callback first and wait for it to complete (important for style switches)
                    if (chapter.callback) {
                        const callbackFn = window[chapter.callback];
                        if (callbackFn && typeof callbackFn === 'function') {
                            // Pass chapter config to callback so it can check onChapterEnter settings
                            if (chapter.callback === 'switchToSatellite') {
                                await callbackFn(chapter);
                            } else {
                                await callbackFn();
                            }
                        }
                    }
                    
                    // Now process onChapterEnter after callback completes (ensures layers exist)
                    if (chapter.onChapterEnter.length > 0) {
                        chapter.onChapterEnter.forEach(layerConfig => {
                            if (layerConfig.field) {
                                updateCensusField(layerConfig.field);
                            }
                            if (layerConfig.layer) {
                                setLayerOpacity(layerConfig);
                            }
                        });
                    }
                    if (chapter.rotateAnimation) {
                        map.once('moveend', () => {
                            const rotateNumber = map.getBearing();
                            map.rotateTo(rotateNumber + 180, {
                                duration: 30000, easing: function (t) {
                                    return t;
                                }
                            });
                        });
                    }
                    if (config.auto) {
                        var next_chapter = (current_chapter + 1) % config.chapters.length;
                        map.once('moveend', () => {
                            document.querySelectorAll('[data-scrollama-index="' + next_chapter.toString() + '"]')[0].scrollIntoView();
                        });
                    }
                })
                .onStepExit(response => {
                    var chapter = config.chapters.find(chap => chap.id === response.element.id);
                    response.element.classList.remove('active');
                    if (chapter.onChapterExit.length > 0) {
                        chapter.onChapterExit.forEach(setLayerOpacity);
                    }
                });


            if (config.auto) {
                document.querySelectorAll('[data-scrollama-index="0"]')[0].scrollIntoView();
            }
        });    

    </script>

</body>

</html>